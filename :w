// SPDX-License-Identifier: MIT
pragma solidity 0.8.25;

import "forge-std/Test.sol";
import {Vault, ASSET_MANAGER_ROLE, FEE_RECEIVER, VALORIZATION_ROLE, HOPPER_ROLE} from "@src/Vault.sol";
import {IERC4626, IERC20Metadata} from "@openzeppelin/contracts/interfaces/IERC4626.sol";
import {Math} from "@openzeppelin/contracts/utils/math/Math.sol";
import {BaseTest} from "./Base.sol";
import {FeeManager} from "@src/FeeManager.sol";
import {Rates} from "@src/FeeManager.sol";

contract TestFeeManager is BaseTest {
    using Math for uint256;

    uint256 _1;
    uint256 _1K;
    uint256 _10K;
    uint256 _100K;
    uint256 _1M;
    uint256 _10M;
    uint256 _20M;
    uint256 _50M;
    uint256 _100M;

    function setUp() public {
        // 10% performance fee
        // 0% management fee
        // 1%  protocol fee
        setUpVault(100, 0, 1_000);

        _1 = 1 * 10 ** vault.underlyingDecimals();
        _1K = 1_000 * 10 ** vault.underlyingDecimals();
        _10K = 10_000 * 10 ** vault.underlyingDecimals();
        _100K = 100_000 * 10 ** vault.underlyingDecimals();
        _1M = 1_000_000 * 10 ** vault.underlyingDecimals();
        _10M = 10_000_000 * 10 ** vault.underlyingDecimals();
        _20M = 20_000_000 * 10 ** vault.underlyingDecimals();
        _50M = 50_000_000 * 10 ** vault.underlyingDecimals();
        _100M = 100_000_000 * 10 ** vault.underlyingDecimals();
    }

    function pricePerShare() internal view returns (uint256 pps) {
        pps = vault.convertToAssets(
            10 ** vault.decimals() // 1 share
        );
    }

    function test_defaultHighWaterMark_equalsPricePerShares() public view {
        assertEq(vault.highWaterMark(), pricePerShare());
    }

    function test_feeReceiverAndDaoHaveNoVaultSharesAtVaultCreation()
        public
        view
    {
        assertEq(vault.balanceOf(vault.feeReceiver()), 0);
        assertEq(vault.balanceOf(vault.protocolFeeReceiver()), 0);
    }

    // +======+=========+==========+======+=======+=========+========+======+===========+=========+
    // | users | deposit | nav | aum  | mfees | profits | pfees  | hwm  | totalFees     |   net   |
    // +======+=========+==========+======+=======+=========+========+======+===========+=========+
    // |    0 | 1       | 0.5        | 0    | 0     | 0       | 1      | 0  | 0         | 0       |
    // +------+---------+----------+------+-------+---------+--------+------+-----------+---------+
    // |    1 | 1M     | 1M + 0.5       | 0    | 0     | 0       | 1      | 0  | 0         | 0    |
    // +------+---------+----------+------+-------+---------+--------+------+-----------+---------+
    //
    // nav update: 1 => 2M
    //
    // highWaterMark: 1
    //
    // pps: 1 => 0.5
    //
    // 0 fees expected
    //
    // Freeride: when pps (price per share) is under highwatermark (highest pps registered)
    //
    function test_ExactNoFeesAreTakenDuringFreeRide() public {
        Rates memory newRates = Rates({
            managementRate: 0,
            performanceRate: 1_000
        });
        updateRates(newRates);
        vm.warp(block.timestamp + 1 days);
        address feeReceiver = vault.feeReceiver();
        address hopperDao = vault.protocolFeeReceiver();

        // ------------ Year 0 ------------ //
        uint256 newTotalAssets = 0;

        // new airdrop !
        dealAmountAndApproveAndWhitelist(user1.addr, 1);
        dealAmountAndApproveAndWhitelist(user2.addr, 1_000_000);

        uint256 ppsAtStart = pricePerShare();

        // user1 deposit into vault at 0$ per share
        requestDeposit(_1, user1.addr);

        // settlement
        updateAndSettle(newTotalAssets);

        assertEq(vault.lastFeeTime(), block.timestamp);
        assertEq(pricePerShare(), ppsAtStart);

        // // user2 will deposit at 0.5$ per shares
        requestDeposit(_1M, user2.addr);

        newTotalAssets = 5 * 10 ** (vault.underlyingDecimals() - 1);

        // settlement
        updateAndSettle(newTotalAssets);

        vm.prank(user2.addr);
        vault.deposit(_1M, user2.addr, user2.addr);

        // no fees should be charged to user 1 because the pps
        // have decreased from 1 to ~0.5 and therefore do not exceed the highWaterMark
        console.log(vault.totalSupply());
        assertEq(
            pricePerShare(),
            5 * 10 ** (vault.underlyingDecimals() - 1),
            "price per share didn't decreased when we expected it to"
        );
        assertEq(vault.balanceOf(vault.feeReceiver()), 0);
        assertEq(vault.balanceOf(vault.protocolFeeReceiver()), 0);

        // ------------ Year 1 ------------ //
        newTotalAssets = 4_000_002 * 10 ** vault.underlyingDecimals();

        // settlement
        updateAndSettle(newTotalAssets);

        assertApproxEqAbs(
            vault.convertToAssets(vault.balanceOf(feeReceiver)),
            198_000 * 10 ** vault.underlyingDecimals(),
            (7 * 10 ** vault.underlyingDecimals()) / 10,
            "Wrong amount of fees taken by fee receiver"
        );
        assertApproxEqAbs(
            vault.convertToAssets(vault.balanceOf(dao.addr)),
            2_000 * 10 ** vault.underlyingDecimals(),
            7 * 10 ** (vault.underlyingDecimals() - 1),
            "Wrong amount of fees taken by dao"
        );

        assertApproxEqAbs(
            vault.pricePerShare(),
            19 * 10 ** (vault.underlyingDecimals() - 1),
            11 * 10 ** (vault.underlyingDecimals() - 1),
            "price per share is wrong"
        );

        assertApproxEqAbs(
            vault.highWaterMark() + 1000000,
            19 * 10 ** (vault.underlyingDecimals() - 1),
            11 * 10 ** (vault.underlyingDecimals() - 1),
            "high water mark is wrong"
        );
    }

    // 1900002249998874998
    //  190000000000000000
    // +======+=========+==========+======+=======+=========+========+======+===========+=========+
    // | users | deposit | nav | aum  | mfees | profits | pfees  | hwm  | totalFees     |   net   |
    // +======+=========+==========+======+=======+=========+========+======+===========+=========+
    // |    0 | 1       | 0.5        | 0    | 0     | 0       | 1      | 0  | 0         | 0       |
    // +------+---------+----------+------+-------+---------+--------+------+-----------+---------+
    // |    1 | 1M     | 1M + 0.5       | 0    | 0     | 0       | 1      | 0  | 0         | 0    |
    // +------+---------+----------+------+-------+---------+--------+------+-----------+---------+
    //
    // nav update: 1 => 2M
    //
    // highWaterMark: 1
    //
    // pps: 1 => 0.5
    //
    // 0 fees expected
    //
    // Freeride: when pps (price per share) is under highwatermark (highest pps registered)
    //
    function test_NoFeesAreTakenDuringFreeRide() public {
        Rates memory newRates = Rates({
            managementRate: 0,
            performanceRate: 2_000
        });
        updateRates(newRates);
        vm.warp(block.timestamp + 1 days);
        address feeReceiver = vault.feeReceiver();
        address hopperDao = vault.protocolFeeReceiver();

        // ------------ Year 0 ------------ //
        uint256 newTotalAssets = 0;

        // new airdrop !
        dealAmountAndApproveAndWhitelist(user1.addr, 1);
        requestDeposit(_1, user1.addr);

        dealAmountAndApproveAndWhitelist(user2.addr, 1_000_000);

        // settlement
        updateAndSettle(newTotalAssets);

        // assertEq(vault.highWaterMark(), expectedHighWaterMark);
        assertEq(vault.balanceOf(feeReceiver), 0);
        assertEq(vault.balanceOf(hopperDao), 0);
        assertEq(vault.lastFeeTime(), block.timestamp);

        // USER 1 deposit into vault at 0$ per share
        assertEq(vault.totalSupply(), 1 * 10 ** vault.decimals());
        assertEq(
            vault.claimableDepositRequest(0, user1.addr),
            1 * 10 ** vault.decimals()
        );

        // // USER2 deposit at 0.5$ per shares
        requestDeposit(_1M, user2.addr);

        newTotalAssets = (5 * 10 ** vault.underlyingDecimals()) / 10;
        // settlement
        updateAndSettle(newTotalAssets);
        assertEq(
            vault.totalAssets(),
            _1M + ((5 * 10 ** vault.underlyingDecimals()) / 10)
        );
        assertEq(
            vault.claimableDepositRequest(0, user1.addr),
            1 * 10 ** vault.underlyingDecimals()
        );
        assertEq(
            vault.claimableDepositRequest(0, user2.addr),
            1_000_000 * 10 ** vault.underlyingDecimals()
        );

        vm.prank(user2.addr);
        vault.deposit(_1M, user2.addr, user2.addr);

        assertApproxEqAbs(
            vault.balanceOf(user2.addr),
            2_000_000 * 10 ** vault.decimals(),
            2 * 10 ** vault.decimals()
        );

        vm.warp(vm.getBlockTimestamp() + 363 days);

        newTotalAssets = 2 * _1M;

        // settlement
        updateAndSettle(newTotalAssets);

        assertEq(vault.balanceOf(feeReceiver), 0);
        assertEq(vault.highWaterMark(), 1 * 10 ** vault.decimals()); // price per share should not move since the vault has not take fees
    }

    // +======+=========+==========+======+=======+=========+========+======+===========+=========+
    // | users | deposit | nav | aum  | mfees | profits | pfees  | hwm  | totalFees     |   net   |
    // +======+=========+==========+======+=======+=========+========+======+===========+=========+
    // |    0 | 1       | 0.5        | 0    | 0     | 0       | 1      | 0  | 0         | 0       |
    // +------+---------+----------+------+-------+---------+--------+------+-----------+---------+
    // |    1 | 1M     | 1M + 0.5       | 0    | 0     | 0       | 1      | 0  | 0         | 0    |
    // +------+---------+----------+------+-------+---------+--------+------+-----------+---------+
    //
    // nav update: 1 => 0.5 => 4M
    //
    // highWaterMark: 1 => 1 => 2
    //
    // pps: 1 => 0.5 => 2
    //
    // 0 fees expected
    //
    // Freeride: when pps (price per share) is under highwatermark (highest pps registered)
    //
    function test_FeesAreTakenAfterFreeride() public {
        Rates memory newRates = Rates({
            managementRate: 0,
            performanceRate: 2_000
        });
        updateRates(newRates);
        vm.warp(block.timestamp + 1 days);

        address feeReceiver = vault.feeReceiver();
        address hopperDao = vault.protocolFeeReceiver();
        // ------------ Year 0 ------------ //
        uint256 newTotalAssets = 0;

        // new airdrop !
        dealAmountAndApproveAndWhitelist(user1.addr, 1);
        requestDeposit(_1, user1.addr);

        dealAmountAndApproveAndWhitelist(user2.addr, 1_000_000);

        // // settlement
        updateAndSettle(newTotalAssets);

        // // assertEq(vault.highWaterMark(), expectedHighWaterMark);
        assertEq(vault.balanceOf(feeReceiver), 0);
        assertEq(vault.balanceOf(hopperDao), 0);
        assertEq(vault.lastFeeTime(), block.timestamp);

        // // USER 1 deposit into vault at 0$ per share
        assertEq(vault.totalSupply(), 1 * 10 ** vault.decimals());
        assertEq(
            vault.claimableDepositRequest(0, user1.addr),
            1 * 10 ** vault.decimals()
        );

        // // USER2 deposit at 0.5$ per shares
        requestDeposit(_1M, user2.addr);

        newTotalAssets = (5 * 10 ** vault.underlyingDecimals()) / 10;
        // settlement
        updateAndSettle(newTotalAssets);
        assertEq(
            vault.totalAssets(),
            _1M + ((5 * 10 ** vault.underlyingDecimals()) / 10)
        );
        assertEq(
            vault.claimableDepositRequest(0, user1.addr),
            1 * 10 ** vault.underlyingDecimals()
        );
        assertEq(
            vault.claimableDepositRequest(0, user2.addr),
            1_000_000 * 10 ** vault.underlyingDecimals()
        );

        vm.prank(user2.addr);
        vault.deposit(_1M, user2.addr, user2.addr);

        assertApproxEqAbs(
            vault.balanceOf(user2.addr),
            2_000_000 * 10 ** vault.decimals(),
            2 * 10 ** vault.decimals(),
            "Wrong amount of shares"
        );

        vm.warp(vm.getBlockTimestamp() + 363 days);

        newTotalAssets = 4 * _1M;

        // settlement
        updateAndSettle(newTotalAssets);

        assertApproxEqAbs(
            vault.convertToAssets(vault.balanceOf(feeReceiver)),
            400_000 * 10 ** vault.underlyingDecimals(),
            5000 * 10 ** vault.underlyingDecimals(),
            "Wrong amount of fees taken"
        );
        assertApproxEqAbs(
            vault.highWaterMark(),
            (18 * 10 ** vault.underlyingDecimals()) / 10,
            10 ** vault.underlyingDecimals(),
            "wrong high water mark"
        ); // price per share should not move since the vault has not take fees
    }
}
